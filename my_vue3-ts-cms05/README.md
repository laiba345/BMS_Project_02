day06 ~ 部门模块
- 303
  - 网络请求部门
    - pageName => user/department/role
    - store => pageName => 增删改查
    - service => pageName => 拼接url => 增删改查
  - 2、将一个页面划分为三个组件～高阶组件
    - page-search：根据search.config.ts 来创建search里面对应应该有的结构
    - 想要达到的效果
      - page-content：根据content.config.ts
      - page-modal：根据modal.config.ts
  - 在components.d.ts 中可能会自动给你导入类型，导致报错
  - 刚复制的文件可能因为缺少生命依赖而报错，可以使用npm install 安装相应的依赖
  - 不想让文件中的内容写死，可以动态写一个配置文件，来进行直接生成
  - Vue3中的defineProps
    - 在Vue3中，defineProps是一个用于定义组件接受的props的函数。它接受一个对象作为参数，该对象包含了组件需要接收的所有props属性及其类型、默认值和验证器等信息。该函数必须在setup()函数内部使用。
    - 使用defineProps定义的props可以通过组件实例的props属性进行访问和响应式更新。与Vue2中不同的是，Vue3中的props默认都是非响应式的，因此不能直接修改props的值。如果需要在组件内部修改props的值，可以通过定义一个与props同名的ref来实现。

- 304
  - 继续动态配置el-table中的内容
  - 先抽取最公共的部分，以及其中最简单的部分；
  - 在进行遍历的时候内容是在template中进行遍历操作
  - 这样的好处就是页面的数据可以通过改变数据的顺序给遍历出来
  - 我们这里是用到了三重判断；缺点：不可能把所有的**类型**都穷举完全
    - 这里列举的都是一些常见的属性；
    - 后面我们还会列举是否有按钮权限；
    - 我们想要做的就是进行相应的定制化；
    - 需要拿到更强的复用性

- 305
  - 想要封装出来的类似的组件更加具有通用性，需要让某一列进行完全定制操作
  - 进行相应的定制化操作
  - 里面的逻辑不想写死，比如前后加上----的时候，为了让组件具有更加的通用性，我们可以在里面再加上一个插槽 ～ 最好来一个具名插槽；
    - 具名插槽中，有个name属性，我们不是写死的，可以在配置文件中加上一个slotName属性
    - 给定了具名插槽，用到不满意需要重新定义的时候找父组件department.vue
    - 我们需要深刻了解定制化

- 306
  - 在page-content当中，发送一些网络请求的时候，发起网络请求和 删除/新建/编辑这一块是写死的，写了一定的页面
  - 但是我们可以多配置一个属性，让别人传数据的时候多传一个组件名字

- 307
  - 我们之前在配置页面的时候一共有三部分，我们还需要对page-modal进行抽取
  - 在进行配置modal.config.ts配置文件的时候，里面有一个下拉框，可能数据没有能够及时回来

- 308
  - 配置里面的属性的名字一定要准确，否则东西是直接不生效的
  - 可以强制将某一个属性转换为any类型，使用any关键字
  - 上级部门那一块很可能来自服务器，那一块是不能写死的

- 309
  - 将相应的类型写在外面会报错 ～ 原因：可能是插件编译的问题
  - page-modal.vue文件中还应该添加pageName属性，避免写死

- 310
  - 对于department.vue进行抽取工作 ～ 点击search、content的操作
  - 在setup中有一部分逻辑永远是相似的，有些是永远一样的，这种情况下，我们可以进行抽取操作
  - setup相同的逻辑抽取，使用hooks
  - @ 默认导出在引入的时候不需要加上大括号
  - 将相应的逻辑～方法逻辑～抽取到hooks

- 311
  - 做角色页面
  - 打开postman，查看权限列表
  - 在搭配好界面的时候，modal处还需要引入相关的逻辑处理
  - 逻辑处，肯定是在role.vue组件中进行书写

- 312 ~ 下午
  - 高阶组件的封装
  - 遇到的两个小问题
    - 1、某个地方的内容导入但是失效了，可以考虑是否引入了多个文件，导致覆盖操作，没用到
    - 2、类型不能导出在外面的文件被引入等，不可以写在
      - const props = defineProps<IModalProps>()
- 313
  - 以前只能编辑export default { setup(){} } 这种语法
  - 但是现在在@vue/compiler-sfc，增加了对<script setup lang="ts">的解析
  - 将高阶组件，抽取到配置文件中
  - 已经开发完了角色页面
  - 做菜单管理，只做菜单管理的page-content
    - 表格中的数据是可以展开的
  - 权限操作(某个人可能只有一种权限，按钮的权限管理)
  - 操作多级菜单，直接是查看Table表格的，这一点很关键～在ElementPlus当中查看即可
    - 首先想要查看这种东西的话，查看文档
      - 需要使用row-key来作为唯一标识
      - 因为想要设置唯一标识，所以在components/page-content中的el-table中设置row-key
      - 如果想要进行展开操作，我们是不能加上type属性的
  - 而且row.id最好不要直接写死；可以在多书写一个配置
    - 配置好了的话，直接使用v-bind进行相关的绑定操作，绑定到el-table当中

- 314
  - 在新建角色的时候，基于前台的权限控制
    - 在新建角色的时候，下方可供于选择，创建出合适的权限
    - 需要的第三方的内容，想要让里面的内容进行自定义操作，这一点很关键
      - 将类型变为自定义类型，
      - 可能自定义的内容很多
      - 我们可以通过slotName来进行区分操作
      - 在page-modal中通过v-if来书写关于自定义类型的样式，这一点很关键
    - 即我们在page-modal.vue中也可以插入我们的插槽结构

- 315
  - Element-plus中的 Tree树形控件/TreeSelect树形选择
  - 此处的菜单应该是完整的菜单，供选择
  - 以前在store中的main中，拿过完整的数据
  - 再次书写一个方法，获取完整的菜单，在service/main.ts中

- 316
  - 在角色管理中，点击新建角色 => 点击确定的时候的业务逻辑相关操作
    - 目前在创建角色的时候，只传入了formData，我们要收集到点击了点了哪些内容的id是什么
    - 树形控件中有很多的事件，其中一个比较关键的是check～点击复选框
    - 通过一个组件传入:otherInfo,另一个组件就可以接收到

- 317
  - 点击了某一个角色列表的时候，在操作那一列需要进行回显操作，但是最开始往往是不对的，之前的信息会有存储（之前的组件没有被销毁，还保留了原来的信息）
  - 编辑回显操作
    - 点击编辑的那一刻，我们需要拿到原来的权限
    - 在hooks当中有点击编辑的那一刻的权限
    - 在hooks当中的编辑方法中，通过回调函数将数据等传过去
    - 而且在hooks中可以对数据进行操作 ～ 递归

- 318
  - 之前已经做了相关的高阶组件的封装
  - 商品类别 & 商品信息 自己搭建 
  - wangEditor是一个库，用来编辑一些自己相关的知识和内容h
  - tree命令可以一键生成树解构
  - echarts生成一些可视化的东西，这个东西需要自己来进行制作
  - 权限控制 ～ 关于按钮的权限控制
    - 之前的增删改查默认你是有了这个权限
    - 但是作为前端，如果不包含某个权限的话，这个按钮最好展示都不给展示出来
    - 对按钮权限进行控制

- 319
  - 按钮权限管理
  - 讲一个小知识 ～ nextTick

- 320
  - 复习
  - 我们就搭建了三个主要的模块，根据这三个模块page- 就可以快速搭建出一个界面出来









